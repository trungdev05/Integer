#!/usr/bin/env python3
"""Regenerate baseline.json using the current benchmark measurements."""

from __future__ import annotations

import argparse
import json
import platform
import subprocess
import sys
from datetime import datetime
from pathlib import Path

import bench


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(description="Update data/baseline.json from benchmark run")
    parser.add_argument("--build-dir", type=Path, default=Path("build"))
    parser.add_argument("--baseline", type=Path, default=Path("data/baseline.json"))
    parser.add_argument("--seed", type=int, default=1024, help="Optional seed metadata for reproducibility")
    parser.add_argument("--skip-build", action="store_true")
    args = parser.parse_args(argv)

    build_dir = args.build_dir
    if not args.skip_build:
        bench.run_process(["cmake", "--build", str(build_dir), "--target", "integer_benchmark"])

    benchmark_binary = build_dir / "benchmarks" / "integer_benchmark"
    if sys.platform == "win32":
        benchmark_binary = benchmark_binary.with_suffix(".exe")

    if not benchmark_binary.exists():
        raise FileNotFoundError(f"Benchmark executable not found: {benchmark_binary}")

    completed = bench.run_process([str(benchmark_binary), "--benchmark_format=json"])
    payload = json.loads(completed.stdout)
    measurements = bench.parse_benchmark_payload(payload)

    baseline = bench.load_baseline(args.baseline) if args.baseline.exists() else {}
    baseline_times = baseline.setdefault("baseline_times", {})
    scoring_system = baseline.setdefault("scoring_system", {
        "baseline_score": 200,
        "max_score": 1000,
        "description": "Score = baseline_score * (baseline_time / current_time), capped at max_score",
    })

    for item in measurements:
        baseline_times[str(item.digits)] = round(item.time_seconds, 6)

    baseline["baseline_info"] = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "seed": args.seed,
        "description": "Baseline performance generated by scripts/update_baseline.py",
        "system": platform.platform(),
        "compiler": detect_compiler(build_dir),
    }

    args.baseline.parent.mkdir(parents=True, exist_ok=True)
    with args.baseline.open("w", encoding="utf-8") as handle:
        json.dump(baseline, handle, indent=2)
        handle.write("\n")

    print(f"Baseline updated at {args.baseline}")
    return 0


def detect_compiler(build_dir: Path) -> str:
    cache = build_dir / "CMakeCache.txt"
    if not cache.exists():
        return "unknown"
    compiler_id = "unknown"
    with cache.open("r", encoding="utf-8", errors="ignore") as handle:
        for line in handle:
            if line.startswith("CMAKE_CXX_COMPILER:"):
                compiler_id = line.split("=", 1)[-1].strip()
            if line.startswith("CMAKE_CXX_COMPILER_VERSION:"):
                version = line.split("=", 1)[-1].strip()
                return f"{compiler_id} {version}" if compiler_id != "unknown" else version
    return compiler_id


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
